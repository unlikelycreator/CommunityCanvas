<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Infinite Whiteboard</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.5.0/dist/socket.io.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    function Whiteboard() {
      const canvasRef = useRef(null);
      const [isDrawing, setIsDrawing] = useState(false);
      const [color, setColor] = useState('#000000');
      const [brushSize, setBrushSize] = useState(5);
      const [mode, setMode] = useState('draw'); // 'draw', 'erase', 'pan'
      const [offset, setOffset] = useState({ x: 0, y: 0 });
      const [scale, setScale] = useState(1);
      const [startPan, setStartPan] = useState(null);
      const socketRef = useRef(null);
      const currentPath = useRef(null);

      useEffect(() => {
        // Initialize Socket.IO
        socketRef.current = io(window.location.origin);

        // Load existing paths
        socketRef.current.on('loadPaths', (paths) => {
          const ctx = canvasRef.current.getContext('2d');
          redrawCanvas(ctx, paths);
        });

        // Receive real-time drawing updates
        socketRef.current.on('draw', (path) => {
          const ctx = canvasRef.current.getContext('2d');
          drawPath(ctx, path);
        });

        // Initialize canvas
        const canvas = canvasRef.current;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const ctx = canvas.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Handle window resize
        const resize = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          redrawCanvas(ctx);
        };
        window.addEventListener('resize', resize);

        // Request initial paths
        socketRef.current.emit('requestPaths');

        // Touch support
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        return () => {
          socketRef.current.disconnect();
          window.removeEventListener('resize', resize);
          canvas.removeEventListener('touchstart', handleTouchStart);
          canvas.removeEventListener('touchmove', handleTouchMove);
          canvas.removeEventListener('touchend', handleTouchEnd);
        };
      }, []);

      const drawPath = (ctx, path) => {
        ctx.save();
        ctx.translate(offset.x, offset.y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.strokeStyle = path.mode === 'erase' ? '#FFFFFF' : path.color;
        ctx.lineWidth = path.mode === 'erase' ? path.brushSize * 2 / scale : path.brushSize / scale;
        path.points.forEach((point, i) => {
          if (i === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        });
        ctx.stroke();
        ctx.restore();
      };

      const redrawCanvas = (ctx, paths = null) => {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        if (paths) {
          paths.forEach((path) => drawPath(ctx, path));
        } else {
          socketRef.current.emit('requestPaths');
        }
      };

      const startDrawing = (x, y) => {
        if (mode !== 'draw' && mode !== 'erase') return;
        setIsDrawing(true);
        const ctx = canvasRef.current.getContext('2d');
        currentPath.current = { points: [{ x, y }], color, mode, brushSize };
        ctx.save();
        ctx.translate(offset.x, offset.y);
        ctx.scale(scale, scale);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = mode === 'erase' ? '#FFFFFF' : color;
        ctx.lineWidth = mode === 'erase' ? brushSize * 2 / scale : brushSize / scale;
        ctx.stroke();
        ctx.restore();
      };

      const draw = (x, y) => {
        if (!isDrawing || (mode !== 'draw' && mode !== 'erase')) return;
        const ctx = canvasRef.current.getContext('2d');
        currentPath.current.points.push({ x, y });
        ctx.save();
        ctx.translate(offset.x, offset.y);
        ctx.scale(scale, scale);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.restore();
      };

      const startPanning = (x, y) => {
        if (mode !== 'pan') return;
        setStartPan({ x: x - offset.x, y: y - offset.y });
      };

      const pan = (x, y) => {
        if (!startPan || mode !== 'pan') return;
        setOffset({
          x: x - startPan.x,
          y: y - startPan.y,
        });
        redrawCanvas(canvasRef.current.getContext('2d'));
      };

      const stopDrawing = () => {
        if (isDrawing) {
          setIsDrawing(false);
          if (currentPath.current) {
            socketRef.current.emit('draw', currentPath.current);
            currentPath.current = null;
          }
        }
      };

      const handleMouseDown = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left - offset.x) / scale;
        const y = (e.clientY - rect.top - offset.y) / scale;
        const clientX = e.clientX;
        const clientY = e.clientY;
        if (e.button === 1 || mode === 'pan') {
          startPanning(clientX, clientY);
        } else if (e.button === 0) {
          startDrawing(x, y);
        }
      };

      const handleMouseMove = (e) => {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = (e.clientX - rect.left - offset.x) / scale;
        const y = (e.clientY - rect.top - offset.y) / scale;
        const clientX = e.clientX;
        const clientY = e.clientY;
        if (startPan || mode === 'pan') {
          pan(clientX, clientY);
        } else if (isDrawing) {
          draw(x, y);
        }
      };

      const handleMouseUp = (e) => {
        if (e.button === 1 || mode === 'pan') {
          setStartPan(null);
        } else if (e.button === 0) {
          stopDrawing();
        }
      };

      const handleWheel = (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(0.1, Math.min(10, scale * zoomFactor));
        const rect = canvasRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const newOffsetX = mouseX - (mouseX - offset.x) * (newScale / scale);
        const newOffsetY = mouseY - (mouseY - offset.y) * (newScale / scale);
        setScale(newScale);
        setOffset({ x: newOffsetX, y: newOffsetY });
        redrawCanvas(canvasRef.current.getContext('2d'));
      };

      const handleTouchStart = (e) => {
        e.preventDefault();
        const rect = canvasRef.current.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left - offset.x) / scale;
        const y = (touch.clientY - rect.top - offset.y) / scale;
        const clientX = touch.clientX;
        const clientY = touch.clientY;
        if (mode === 'pan') {
          startPanning(clientX, clientY);
        } else {
          startDrawing(x, y);
        }
      };

      const handleTouchMove = (e) => {
        e.preventDefault();
        const rect = canvasRef.current.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left - offset.x) / scale;
        const y = (touch.clientY - rect.top - offset.y) / scale;
        const clientX = touch.clientX;
        const clientY = touch.clientY;
        if (startPan || mode === 'pan') {
          pan(clientX, clientY);
        } else if (isDrawing) {
          draw(x, y);
        }
      };

      const handleTouchEnd = (e) => {
        e.preventDefault();
        if (mode === 'pan') {
          setStartPan(null);
        } else {
          stopDrawing();
        }
      };

      return (
        <div className="flex flex-col h-screen bg-gray-100">
          <div className="p-4 bg-white shadow-md flex flex-wrap items-center gap-4">
            <div className="flex items-center gap-2">
              <label className="font-semibold">Tool:</label>
              <button
                onClick={() => setMode('draw')}
                className={`px-3 py-1 rounded-md ${mode === 'draw' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
              >
                Draw
              </button>
              <button
                onClick={() => setMode('erase')}
                className={`px-3 py-1 rounded-md ${mode === 'erase' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
              >
                Erase
              </button>
              <button
                onClick={() => setMode('pan')}
                className={`px-3 py-1 rounded-md ${mode === 'pan' ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
              >
                Pan
              </button>
            </div>
            <div className="flex items-center gap-2">
              <label className="font-semibold">Color:</label>
              <input
                type="color"
                value={color}
                onChange={(e) => setColor(e.target.value)}
                className="w-8 h-8 rounded"
              />
            </div>
            <div className="flex items-center gap-2">
              <label className="font-semibold">Brush Size:</label>
              <input
                type="range"
                min="1"
                max="20"
                value={brushSize}
                onChange={(e) => setBrushSize(Number(e.target.value))}
                className="w-24"
              />
              <span>{brushSize}px</span>
            </div>
            <div className="flex items-center gap-2">
              <label className="font-semibold">Zoom:</label>
              <button
                onClick={() => {
                  const newScale = Math.min(10, scale * 1.1);
                  setScale(newScale);
                  redrawCanvas(canvasRef.current.getContext('2d'));
                }}
                className="px-3 py-1 bg-gray-200 rounded-md"
              >
                +
              </button>
              <button
                onClick={() => {
                  const newScale = Math.max(0.1, scale * 0.9);
                  setScale(newScale);
                  redrawCanvas(canvasRef.current.getContext('2d'));
                }}
                className="px-3 py-1 bg-gray-200 rounded-md"
              >
                -
              </button>
              <span>{Math.round(scale * 100)}%</span>
            </div>
          </div>
          <canvas
            ref={canvasRef}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onWheel={handleWheel}
            className="flex-grow bg-white cursor-crosshair"
          />
        </div>
      );
    }

    ReactDOM.render(<Whiteboard />, document.getElementById('root'));
  </script>
</body>
</html>
